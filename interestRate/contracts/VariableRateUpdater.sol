// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;
import { AutomationCompatibleInterface } from "@chainlink/interfaces/automation/AutomationCompatibleInterface.sol";
import { IPoolAddressesProvider } from '@aave-v3/contracts/interfaces/IPoolAddressesProvider.sol';
import { IDynamicRateStrategy } from '../interfaces/IDynamicRateStrategy.sol';
import { IPool } from '@aave-v3/contracts/interfaces/IPool.sol';
import { WadRayMath } from '@aave-v3/contracts/protocol/libraries/math/WadRayMath.sol';
import { PercentageMath } from '@aave-v3/contracts/protocol/libraries/math/PercentageMath.sol';
import { DataTypes } from '@aave-v3/contracts/protocol/libraries/types/DataTypes.sol';


interface DebtTokenLike {
    function totalSupply() external view returns (uint256);
}

interface ATokenLike {
    function totalSupply() external view returns (uint256);
}


contract VariableRateUpdater is AutomationCompatibleInterface {
    using WadRayMath for uint256;
    using PercentageMath for uint256;
    uint public counter;
    
    uint public constant INTERVAL = 12 hours;
    uint public constant WINDOW = 60; // 60 days

    IPoolAddressesProvider public immutable ADDRESSES_PROVIDER;
    IPool public immutable POOL;
    address public immutable ASSET;

    uint[] public utilizationHistory;

    uint public avgUtilization;

    uint public lastTimeStamp;

    constructor(
        IPoolAddressesProvider _provider,
        address _asset, 
        uint256[] memory _utilizationHistory
    ) {
        require(_utilizationHistory.length == 60, "VariableRateUpdate/length");
        utilizationHistory = _utilizationHistory;

        ADDRESSES_PROVIDER = _provider;
        POOL = IPool(_provider.getPool());
        ASSET = _asset;

        lastTimeStamp = block.timestamp;
        counter = 0;
    }

    function checkUpkeep(
        bytes calldata /* checkData */
    )
        external
        view
        override
        returns (bool upkeepNeeded, bytes memory performData)
    {
        upkeepNeeded = (block.timestamp - lastTimeStamp) > INTERVAL; //every 6 hours an upkeep is need
        uint _avgUtilization;
        for(uint k = 0; k < 60; k ++) {
            _avgUtilization += utilizationHistory[k];
        }
        _avgUtilization = _avgUtilization / 60;

        IDynamicRateStrategy rateStrategy = IDynamicRateStrategy(POOL.getReserveData(ASSET).interestRateStrategyAddress);

        uint optimalUtilization = rateStrategy.OPTIMAL_USAGE_RATIO();
        uint epsilon = rateStrategy.EPSILON();
        uint variableRateSlope1 = rateStrategy.getVariableRateSlope1();
        uint mPlus = rateStrategy.getMPlus();
        uint mMinus = rateStrategy.getMMinus();

        if (_avgUtilization < optimalUtilization - epsilon) {
            variableRateSlope1 = variableRateSlope1.percentMul(mMinus);
        } else {
            variableRateSlope1 = variableRateSlope1.percentMul(mPlus).rayMul(WadRayMath.RAY - (_avgUtilization + epsilon - optimalUtilization));
        }

        // This will be used by the keeper to update the interest rate strategy
        performData = abi.encode(variableRateSlope1);
    }


    function performUpkeep(bytes calldata performData) external override {
        //We highly recommend revalidating the upkeep in the performUpkeep function

        DataTypes.ReserveData memory reserve = POOL.getReserveData(ASSET);

        // Compute usage ratio
        uint256 totalVariableDebt = DebtTokenLike(reserve.variableDebtTokenAddress).totalSupply();
        uint256 totalStableDebt = DebtTokenLike(reserve.stableDebtTokenAddress).totalSupply();
        // THIS DOES NOT WORK WHEN THERE IS BAD DEBT ? BUT THIS IS ACTUALLY ENOUGH SINCE WHEN CALLING THIS WE ARE NOT CHANGING THE LIQUIDITY
        uint256 totalReserve = ATokenLike(reserve.aTokenAddress).totalSupply();
        uint256 totalDebt = totalStableDebt + totalVariableDebt;
        uint256 utilizationRatio = totalDebt.rayDiv(totalReserve);

        if ((block.timestamp - lastTimeStamp) > INTERVAL) {
            lastTimeStamp = block.timestamp;
            utilizationHistory[counter % 60] = utilizationRatio;
            counter = counter + 1;
        }
        //here we assume that there's no lapse
        uint256 variableRateSlope1 = abi.decode(performData, (uint256));
        IDynamicRateStrategy rateStrategy = IDynamicRateStrategy(reserve.interestRateStrategyAddress);

        rateStrategy.setVariableRateSlope1(variableRateSlope1);

        // We don't use the performData in this example. The performData is generated by the Automation Node's call to your checkUpkeep function
    }
}